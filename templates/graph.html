<!DOCTYPE html>
<meta charset="utf-8">

<link rel="stylesheet" href="{{ url_for('static', filename='vizstyle.css') }}">

<svg width="1720" height="820"></svg> 
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>


<script>

    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height"),
        color = d3.scaleOrdinal(d3.schemeCategory10);


    /////// SLIDER ///////
    var L = 10;
    var slider_size = 0.75*width;
    var left_margin = 0.5*(width - slider_size);

    var x = d3.scaleLinear()
        .domain([0,10])
        .range([left_margin, slider_size + left_margin])
        .clamp(true);

    var slider = svg.append("g")
        .attr("transform", "translate(15,"+(height-50)+")");

    slider.append("line")
        .attr("class", "track")
        .attr("x1", x.range()[0])
       .attr("x2", x.range()[1])
       .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
       .attr("class", "track-inset")
        .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
        .attr("class", "track-overlay")
        .call(d3.drag()
            .on("start.interrupt", function() { slider.interrupt(); })
            .on("start drag", function() { return hue(x.invert(d3.event.x)); }));

    var epochs = d3.range(0, {{ data.epochs }}, 1)
    var dx = L/(epochs.length-1)
    var xticks = d3.range(0,L+dx,dx)

    slider.insert("g", ".track-overlay")
        .attr("class", "ticks")
        .attr("transform", "translate(0," + 25 + ")")
      .selectAll("text")
      .data(xticks)
      .enter().append("text")
        .attr("x", x)
        .attr("text-anchor", "middle")
        .text(function(d,i) { return epochs[i]; });

    var handle = slider.insert("circle", ".track-overlay")
        .attr("class", "handle")
        .attr("r", 9)
        .attr("cx", x.range()[0]); //initial position to zero

    function hue(h) {
      handle.attr("cx", x(h));
    }

    function dragstarted(d) {
      if (!d3.event.active) simulation.alphaTarget(0).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }

    function dragended(d) {
      if (!d3.event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }


    /////// GRAPH ////////
    var myGraph = {{ data.graph_data | safe }}
    
    function showGraph(graph) {
       //user-defined parameters
       var maxDistance = 60, //max distance between two nodes
           minDistance = 10, //min distance betwween two nodes
           maxRadius = 12, //max radius of circle
           minRadius = 2, //min radius of circle
           minLinkwidth = 0, //min width of link
           maxLinkwidth = 4, //max width of link
           margin = 50

       var [maxConnect, maxNorm] = getnetworkProp(graph);

       var nodes = graph.nodes,
         nodeById = d3.map(nodes, function(d) { return d.id; }),
         links = graph.links,
         value = links.map(function(d){return d.value}),

       l = []
       links.forEach(function(link) {
           var s = nodeById.get(link.source),
               t = nodeById.get(link.target),
               v = link.value,
               y = link.epoch;

           l.push({source: s, target: t, epoch: y, value:v});
         });

       links = l


       simulation = d3.forceSimulation(nodes)
          .force("charge", d3.forceManyBody().strength(-0.5))
          .force("link", d3.forceLink(links))
          .on("tick", ticked);


       var g = svg.append("g").attr("transform", "translate(" + width / 2 + "," + 0.45 * height + ")"),
           link = g.append("g").attr("stroke", "#000").attr("stroke-width", 1.5).selectAll(".link"),
           node = g.append("g").attr("stroke", "#fff").attr("stroke-width", 1.5).selectAll(".node");

       restart();

       d3.interval(function() {
           restart();
       },150)


       function restart() {

         var current_epoch = epochs[Math.round(x.invert(jQuery(".handle").attr("cx"))/dx)];
         //get "radius" of each node for current_epoch
         var norm = graph.nodes.map(function(d) {return d.norm}).map(function(d) {return d[current_epoch.toString()];})

         // Apply the general update pattern to the nodes.
         node = node.data(nodes, function(d) { return d.id;});
         node.exit().remove();
         node = node.enter().append("circle")
                   .attr("class","node")
                   .attr("fill", function(d) { if(parseInt(d.id)<256){  // changeme
                               return color("0");  
                           }
                           else{
                               return color("1");
                           }})  // changeme: color for pruned and vanilla models - return color(d.id);
                   .merge(node)
                   .call(d3.drag()
                       .on("start", dragstarted)
                       .on("drag", dragged)
                       .on("end", dragended));

         node.append("title")
             .text(function(d) { return d.id; });

         //apply transition to radii of nodes
         node.transition()
             .duration(50)
               .attr("r",function(d) {return Math.max(minRadius,d.norm[current_epoch.toString()]/maxNorm * maxRadius);})

         // Apply the general update pattern to the links
         links_filtered = links.filter(function(d) {return d.epoch==current_epoch;});
         link = link.data(links_filtered, function(d) { return d.source.id + "-" + d.target.id; });
         link.exit().remove();
         link = link.enter()
             .append("line")
             .attr("class", "link")
             .merge(link);

         //define transition to width of edges
         link.transition()
               .duration(50)
               .attr("stroke-width", function(d,i) { return  Math.max(minLinkwidth,d.value/maxConnect * maxLinkwidth);})


         // Update and restart the simulation.
         simulation.nodes(nodes);
         simulation.force("link").links(links_filtered)  // changed (links)
         simulation.force("link", d3.forceLink(links_filtered)  // changed (links)
                        .distance(function(d) {
                           if(d.epoch==current_epoch){
                               return Math.min(maxConnect/d.value * minDistance,maxDistance);  
                           }
                           else{
                               return maxDistance;  // changed (maxDistance)
                           }})
                          )

         simulation.alpha(0.4).restart();
       }

       //this function defines position of nodes and links
       //at each "simulation time step"
       function ticked() {

          graph.nodes.forEach(function(d) { 
            d.x = Math.max(-0.5*width + margin, Math.min(0.5*width - margin, d.x))
            d.y = Math.max(-0.5*height + margin, Math.min(0.5*height - margin, d.y))
         }) 

         node.attr("cx", function(d) { return d.x; })
             .attr("cy", function(d) { return d.y; })

         link.attr("x1", function(d) { return d.source.x; })
             .attr("y1", function(d) { return d.source.y; })
             .attr("x2", function(d) { return d.target.x; })
             .attr("y2", function(d) { return d.target.y; });
       }


    }

    showGraph(myGraph);

    //this function calculates properties of network
    //(i.e., max connection between nodes, max norm value of node)
    function getnetworkProp(graph){
       //1) max connection between nodes
       var maxConnect = Math.max.apply(Math,graph.links.map(function(d) {return d.value;}));   //max connection between nodes

       //2) max norm value (used to draw nodes radii)
       var maxNorm = 0;
       var arr, obj, maxf;
       for (i=0;i<graph.nodes.length;i++){
           obj = graph.nodes[i].norm
           arr = Object.keys( obj ).map(function (key) { return obj[key]; });
           maxf = Math.max.apply( null, arr );
           maxNorm = Math.max(maxNorm,maxf);
       }
       return [maxConnect, maxNorm];
    }

</script>
